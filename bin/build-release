#!/bin/bash
# Build the project in release mode.
# The generated release directory and zip file name is in the for of:
#   "${RELEASE_FILE_PREFIX}${<target-name>}${RELEASE_FILE_SUFFIX}-${RELEASE_VERSION}"
# All command-line arguments are passed to the executed `cargo` command.
# Optional environment variables:
#   $RELEASE_TARGETS
#     A space-separated list of build target identifiers;
#     valid identifiers are: "default" (host's target triple), "linux", "windows".
#     DEFAULT: "linux windows"
#   $RELEASE_DIR
#     Directory path for the generated releases to be saved to.
#     DEFAULT: "releases/" directory next to the project root.
#   $RELEASE_VERSION
#     Version number which is used in the generated release directory and zip file names.
#     DEFAULT: Dynamically figures out the highest version number in the releases directory
#              and uses its increment as the version. 0 if no version numbers were found.
#   $RELEASE_FILE_PREFIX
#     Prefix string for the generated release directory and zip file.
#     DEFAULT: "ld44-postjam-"
#   $RELEASE_FILE_SUFFIX
#     Suffix string for the generated release directory and zip file.
#     DEFAULT: ""
#   $RELEASE_EXE_NAME
#     Name of the executable generated by cargo/rust.
#     DEFAULT: "LD44" or "LD44.exe" (for windows)
#   $RELEASE_RESOURCES_DIR
#     Path to the resources directory.
#     DEFAULT: "${ROOT}/resources"
#   $RELEASE_RUST_VERSION
#     Which rust version to use.
#     Can be anything that can be passed to `rustup run VERSION`,
#     for example: "stable", "nightly", "1.34.2", "2019-01-01"
#     DEFAULT: "1.34.2"

# shellcheck source=./util.sh
_dir="$( dirname "$0" )"
[ -f "${_dir}/util.sh" ] || bash "${_dir}/download-util.sh" || exit 1
source "${_dir}/util.sh"
unset _dir

set -e

LOGFILE="${ROOT}/logs/$( basename "$0" ).log"
WINDOWS_TARGET="x86_64-pc-windows-gnu"
INCLUDE_FILES=()
[ -f "${ROOT}/README.md" ]      && INCLUDE_FILES+=("${ROOT}/README.md")
[ -f "${ROOT}/LICENSE" ]      && INCLUDE_FILES+=("${ROOT}/LICENSE")
[ -f "${ROOT}/resolution.txt" ] && INCLUDE_FILES+=("${ROOT}/resolution.txt")

function get_latest_version {
  check "sed"
  shopt -s nullglob
  [ -d "$RELEASE_DIR" ] || err "Directory '$RELEASE_DIR' doesn't exist."
  local highest=0
  local vers
  local vers_num
  local highest_num
  local file
  local new_vers

  for file in "$RELEASE_DIR"/*.zip; do
    vers="$( echo "$file" | grep -Eo '([0-9]\.?)+\.zip' | sed 's/\.zip//' )"
    if [ -n "$vers" ]; then
      vers_num="${vers//./}"
      highest_num="${highest//./}"
      [ $vers_num -gt $highest_num ] && highest="$vers"
    fi
  done

  new_vers="$( echo "$highest" | sed -E 's/(.*)([0-9]+)$/echo "\1$((\2+1))"/e' )"
  echo "$new_vers"
}

function get_filename_for_target {
  local target="$1"
  [ -z "$target" ] && err "No target name given to function \`$0\`."
  echo "${RELEASE_FILE_PREFIX}${target}${RELEASE_FILE_SUFFIX}-${RELEASE_VERSION}"
}

function mk_archive {
  local path="$1"
  local dir
  local filename
  [ -z "$1" ] && err "No path given to function \`$0\`."
  check "zip" && check "dirname" && check "basename"
  dir="$( dirname "$path" )"
  [ -n "$dir" ] && cd "$dir"
  filename="$( basename "$path" )"
  msg "${spacing}Zipping directory..."
  try_run "zip -r ${filename}.zip $filename"
  try_run "rm -rf $filename"
}

function build_release {
  check "cargo"
  local target_display
  local filename
  local target
  local spacing

  msg_strong "Building release version $( colored "$COLOR_CODE" "$RELEASE_VERSION" )"

  for target in "${RELEASE_TARGETS[@]}"; do
    echo  # Empty line

    spacing_strong="  "
    target_display="$( colored "$COLOR_CODE" "$target" )"
    msg_strong "${spacing_strong}Building release for $target_display"
    filename="$( get_filename_for_target "$target" )"
    spacing="${spacing_strong}${spacing_strong}"

    case "$target" in
      "linux" | "default")
        build_release_for_linux "$@"
        ;;

      "windows")
        build_release_for_windows "$@"
        ;;

      *)
        err "Target '$target_display' is not valid"
        ;;
    esac

    msg_strong "${spacing_strong}Created release for ${target_display}\n${spacing_strong}$( colored "$COLOR_CODE" "${RELEASE_DIR}/${filename}.zip" )"
  done
}

# Pre-set local variables:
#   local target_display
#   local filename
#   local target
#   local spacing
function build_release_for_linux {
  msg "${spacing}Compiling..."
  try_run "cargo +${RELEASE_RUST_VERSION} build --release $*"

  target_dir="${RELEASE_DIR}/${filename}"
  mkdir "$target_dir"

  msg "${spacing}Copying executable and resources..."
  try_run "cp ${ROOT}/target/release/${RELEASE_EXE_NAME} $target_dir"
  try_run "cp -r $RELEASE_RESOURCES_DIR $target_dir"
  try_run "cp ${INCLUDE_FILES[*]} $target_dir"

  mk_archive "$target_dir"
}

# Pre-set local variables:
#   local target_display
#   local filename
#   local target
#   local spacing
function build_release_for_windows {
  msg "${spacing}Compiling..."
  try_run "cargo +${RELEASE_RUST_VERSION} build --release --target $WINDOWS_TARGET $*"

  target_dir="${RELEASE_DIR}/${filename}"
  mkdir "$target_dir"

  msg "${spacing}Copying executable and resources..."
  try_run "cp ${ROOT}/target/${WINDOWS_TARGET}/release/${RELEASE_EXE_NAME}.exe $target_dir"
  try_run "cp -r $RELEASE_RESOURCES_DIR $target_dir"
  try_run "cp ${INCLUDE_FILES[*]} $target_dir"

  mk_archive "$target_dir"
}

# Set global settings variables.
[ -z "$RELEASE_TARGETS" ] && RELEASE_TARGETS="linux windows"
RELEASE_TARGETS=($RELEASE_TARGETS)
[ -z "$RELEASE_DIR" ]           && RELEASE_DIR="${ROOT}/releases"
[ -d "$RELEASE_DIR" ]           || mkdir -p "$RELEASE_DIR"
[ -z "$RELEASE_VERSION" ]       && RELEASE_VERSION="$( get_latest_version )"
[ -z "$RELEASE_FILE_PREFIX" ]   && RELEASE_FILE_PREFIX="ld44-postjam-"
[ -z "$RELEASE_FILE_SUFFIX" ]   && RELEASE_FILE_SUFFIX=""
[ -z "$RELEASE_EXE_NAME" ]      && RELEASE_EXE_NAME="LD44"
[ -z "$RELEASE_RESOURCES_DIR" ] && RELEASE_RESOURCES_DIR="${ROOT}/resources"
[ -z "$RELEASE_RUST_VERSION" ]  && RELEASE_RUST_VERSION="1.34.2"

build_release "$@"
