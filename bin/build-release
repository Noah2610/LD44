#!/bin/bash
# Build the project in release mode.
# The generated release directory and zip file name is in the format of:
#   "${RELEASE_FILE_PREFIX}${<target-name>}${RELEASE_FILE_SUFFIX}-${RELEASE_VERSION}"
#
# All command-line arguments are passed to the executed `cargo` command.
#
# Optional environment variables:
#   $RELEASE_TARGETS
#     A space-separated list of build target identifiers;
#     valid identifiers are: "default" (host's target triple), "linux", "windows".
#     DEFAULT: "linux windows"
#   $RELEASE_DIR
#     Directory path for the generated releases to be saved to.
#     DEFAULT: "releases/" directory next to the project root.
#   $RELEASE_VERSION
#     Version number which is used in the generated release directory and zip file names.
#     DEFAULT: Dynamically figures out the highest version number in the releases directory
#              and uses its increment as the version. 0 if no version numbers were found.
#   $RELEASE_FILE_PREFIX
#     Prefix string for the generated release directory and zip file.
#     DEFAULT: "ld44-postjam-"
#   $RELEASE_FILE_SUFFIX
#     Suffix string for the generated release directory and zip file.
#     DEFAULT: ""
#   $RELEASE_EXE_NAME
#     Name of the executable generated by cargo/rust.
#     DEFAULT: "LD44" or "LD44.exe" (for windows)
#   $RELEASE_EXE_NAME_OUTPUT
#     Name of the executable to be included in the release.
#     DEFAULT: "Stabman" or "Stabman.exe" (for windows)
#   $RELEASE_RESOURCES_DIR
#     Path to the resources directory.
#     DEFAULT: "${ROOT}/resources"
#   $RELEASE_RUST_VERSION
#     Which rust version to use.
#     Can be anything that can be passed to `rustup run VERSION`,
#     for example: "stable", "nightly", "1.34.2", "2019-01-01"
#     DEFAULT: "1.34.2"
#   $RELEASE_FEATURES
#     Comma-separated list of features to build with.
#     DEFAULT: ""
#   $RELEASE_WITH_CONTROLLER
#     If an additional executable with enabled controller support
#     shall be built in addition to the regular one.
#     Enabled if value is non-empty and not "0".
#     The extra executable will not be bundled with the generated zip archive,
#     instead it is placed in the releases directory in a zip archive with a name in the form of:
#       "${RELEASE_FILE_PREFIX}${<target-name>}${RELEASE_FILE_SUFFIX}-${RELEASE_VERSION}${CONTROLLER_SUPPORT_SUFFIX}.zip"
#     The executable in this zip archive will have a name in the form of:
#       "${RELEASE_EXE_NAME}${CONTROLLER_SUPPORT_SUFFIX}(.exe)"
#     The ".exe" at the end is only appended for windows executables.
#     DEFAULT: "0"

# shellcheck source=./share.sh
_dir="$( dirname "$0" )"
source "${_dir}/share.sh"
unset _dir

set -e

WINDOWS_TARGET="x86_64-pc-windows-gnu"
CONTROLLER_SUPPORT_SUFFIX="-with-controller"
INCLUDE_FILES=()

function include_file {
  local filepath="${ROOT}/${1}"
  if [ -f "$filepath" ]; then
    INCLUDE_FILES+=("$filepath")
  else
    msg_strong "File to include in archive does not exist: $( colored "$COLOR_CODE" "$filepath" )"
  fi
}

function exclude_file {
  local filepath_remove=("${ROOT}/${1}")
  INCLUDE_FILES=("${INCLUDE_FILES[@]/$filepath_remove}")
}

include_file "README.md"
include_file "LICENSE"
include_file "resolution.txt"

function get_latest_version {
  check "sed"
  shopt -s nullglob
  [ -d "$RELEASE_DIR" ] || err "Directory '$RELEASE_DIR' doesn't exist."
  local highest=0
  local vers
  local vers_num
  local highest_num
  local file
  local new_vers

  for file in "$RELEASE_DIR"/*.zip; do
    vers="$( echo "$file" | grep -Eo '([0-9]\.?)+\.zip' | sed 's/\.zip//' )"
    if [ -n "$vers" ]; then
      vers_num="${vers//./}"
      highest_num="${highest//./}"
      [ $vers_num -gt $highest_num ] && highest="$vers"
    fi
  done

  new_vers="$( echo "$highest" | sed -E 's/(.*)([0-9]+)$/echo "\1$((\2+1))"/e' )"
  echo "$new_vers"
}

function get_filename_for_target {
  local target="$1"
  [ -z "$target" ] && err "No target name given to function \`$0\`."
  echo "${RELEASE_FILE_PREFIX}${target}${RELEASE_FILE_SUFFIX}-${RELEASE_VERSION}"
}

function mk_archive {
  local path="$1"
  local dir
  local filename
  [ -z "$1" ] && err "No path given to function \`$0\`."
  check "zip" && check "dirname" && check "basename"
  dir="$( dirname "$path" )"
  [ -n "$dir" ] && cd "$dir"
  filename="$( basename "$path" )"
  msg "${spacing}Zipping directory..."
  try_run "zip -r ${filename}.zip $filename"
  try_run "rm -rf $filename"
}

function build_release {
  check "cargo"
  local target_display
  local filename
  local target
  local spacing

  msg_strong "Building release version $( colored "$COLOR_CODE" "$RELEASE_VERSION" )"

  for target in "${RELEASE_TARGETS[@]}"; do
    echo  # Empty line

    spacing_strong="  "
    target_display="$( colored "$COLOR_CODE" "$target" )"
    msg_strong "${spacing_strong}Building release for $target_display"
    filename="$( get_filename_for_target "$target" )"
    spacing="${spacing_strong}${spacing_strong}"

    case "$target" in
      "linux" | "default")
        build_release_for_linux "$@"
        ;;

      "windows")
        build_release_for_windows "$@"
        ;;

      *)
        err "Target '$target_display' is not valid"
        ;;
    esac

    msg_strong "${spacing_strong}Created release for ${target_display}\n${spacing_strong}$( colored "$COLOR_CODE" "${RELEASE_DIR}/${filename}.zip" )"
  done
}

# Pre-set local variables:
#   local target_display
#   local filename
#   local target
#   local spacing
function build_release_for_linux {
  exclude_file "SDL2.dll"

  local features_arg=""
  [ -n "$RELEASE_FEATURES" ] && features_arg="--features ${RELEASE_FEATURES}"
  msg "${spacing}Compiling..."
  try_run "cargo +${RELEASE_RUST_VERSION} build --release ${features_arg} $*"

  local target_dir="${RELEASE_DIR}/${filename}"
  mkdir "$target_dir"

  msg "${spacing}Copying executable and resources..."
  try_run "cp ${ROOT}/target/release/${RELEASE_EXE_NAME} ${target_dir}/${RELEASE_EXE_NAME_OUTPUT}"
  try_run "cp -r $RELEASE_RESOURCES_DIR $target_dir"
  try_run "cp ${INCLUDE_FILES[*]} $target_dir"

  mk_archive "$target_dir"

  if should_build_with_controller; then
    msg "${spacing}Compiling with controller support..."
    cd "${RELEASE_DIR}"
    local exe_name="${RELEASE_EXE_NAME_OUTPUT}${CONTROLLER_SUPPORT_SUFFIX}"
    local zip_name="${RELEASE_FILE_PREFIX}${target}${RELEASE_FILE_SUFFIX}-${RELEASE_VERSION}${CONTROLLER_SUPPORT_SUFFIX}"
    local features
    if [ -n "$RELEASE_FEATURES" ]; then
      features="${RELEASE_FEATURES},controller"
    else
      features="controller"
    fi
    try_run "cargo +${RELEASE_RUST_VERSION} build --release --features $features $*"
    try_run "cp ${ROOT}/target/release/${RELEASE_EXE_NAME} ${exe_name}"
    try_run "zip -r ${zip_name}.zip ${exe_name}"
    try_run "rm -f ${exe_name}"
  fi
}

# Pre-set local variables:
#   local target_display
#   local filename
#   local target
#   local spacing
function build_release_for_windows {
  [[ "$RELEASE_FEATURES" =~ "controller" ]] && include_file "SDL2.dll"

  local features_arg=""
  [ -n "$RELEASE_FEATURES" ] && features_arg="--features ${RELEASE_FEATURES}"
  msg "${spacing}Compiling..."
  try_run "cargo +${RELEASE_RUST_VERSION} build --release --target ${WINDOWS_TARGET} ${features_arg} $*"

  local target_dir="${RELEASE_DIR}/${filename}"
  mkdir "$target_dir"

  msg "${spacing}Copying executable and resources..."
  try_run "cp ${ROOT}/target/${WINDOWS_TARGET}/release/${RELEASE_EXE_NAME}.exe ${target_dir}/${RELEASE_EXE_NAME_OUTPUT}.exe"
  try_run "cp -r $RELEASE_RESOURCES_DIR $target_dir"
  try_run "cp ${INCLUDE_FILES[*]} $target_dir"

  mk_archive "$target_dir"

  if should_build_with_controller; then
    msg "${spacing}Compiling with controller support..."
    cd "${RELEASE_DIR}"
    local sdl2_file="SDL2.dll"
    local exe_name="${RELEASE_EXE_NAME_OUTPUT}${CONTROLLER_SUPPORT_SUFFIX}.exe"
    local zip_name="${RELEASE_FILE_PREFIX}${target}${RELEASE_FILE_SUFFIX}-${RELEASE_VERSION}${CONTROLLER_SUPPORT_SUFFIX}"
    local features
    if [ -n "$RELEASE_FEATURES" ]; then
      features="${RELEASE_FEATURES},controller"
    else
      features="controller"
    fi
    try_run "cargo +${RELEASE_RUST_VERSION} build --release --target ${WINDOWS_TARGET} --features $features $*"
    try_run "cp ${ROOT}/target/${WINDOWS_TARGET}/release/${RELEASE_EXE_NAME}.exe ${exe_name}"
    try_run "cp ${ROOT}/${sdl2_file} ${sdl2_file}"
    try_run "zip -r ${zip_name}.zip ${exe_name} ${sdl2_file}"
    try_run "rm -f ${exe_name} ${sdl2_file}"
  fi
}

function should_build_with_controller {
  [ -n "$RELEASE_WITH_CONTROLLER" ] && [ "$RELEASE_WITH_CONTROLLER" != "0" ]
}

# Set global settings variables.
[ -z "$RELEASE_TARGETS" ] && RELEASE_TARGETS="linux windows"
RELEASE_TARGETS=($RELEASE_TARGETS)
[ -z "$RELEASE_DIR" ]             && RELEASE_DIR="${ROOT}/releases"
[ -d "$RELEASE_DIR" ]             || mkdir -p "$RELEASE_DIR"
[ -z "$RELEASE_VERSION" ]         && RELEASE_VERSION="$( get_latest_version )"
[ -z "$RELEASE_FILE_PREFIX" ]     && RELEASE_FILE_PREFIX="ld44-postjam-"
[ -z "$RELEASE_FILE_SUFFIX" ]     && RELEASE_FILE_SUFFIX=""
[ -z "$RELEASE_EXE_NAME" ]        && RELEASE_EXE_NAME="LD44"
[ -z "$RELEASE_EXE_NAME_OUTPUT" ] && RELEASE_EXE_NAME_OUTPUT="Stabman"
[ -z "$RELEASE_RESOURCES_DIR" ]   && RELEASE_RESOURCES_DIR="${ROOT}/resources"
[ -z "$RELEASE_RUST_VERSION" ]    && RELEASE_RUST_VERSION="1.34.2"
[ -z "$RELEASE_FEATURES" ]        && RELEASE_FEATURES=""
[ -z "$RELEASE_WITH_CONTROLLER" ] && RELEASE_WITH_CONTROLLER="0"

build_release "$@"
